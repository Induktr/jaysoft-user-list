# Документація UI «Jaysoft User List»

### 1. Вступ: Система з двох компонентів

UI проекту побудований на **простій, але ефективній системі (Принцип 9)** з двох компонентів, що забезпечує **якість (Принцип 3)** і **легкість підтримки**.

### 2. Компоненти системи

#### **1. `App.vue` (Компонент-оркестратор)**
*   **Роль:** «Мозок» додатка. Відповідає за:
1.  **Отримання даних:** У хуку `onMounted` асинхронно запитує список користувачів з API.
    2.  **Зберігання стану:** Зберігає вихідний масив користувачів (`users`) і рядок пошуку (`searchQuery`) в реактивних `ref`.
    3.  ** Обчислення логіки:** Містить `computed`-властивість `filteredUsers`, яка **ефективно і декларативно** фільтрує список на основі `searchQuery`.
    4.  **Рендеринг списку:** Використовує `v-for` для ітерації по `filteredUsers` і рендерингу компонентів `UserCard`.

#### **2. `UserCard.vue` (Компонент-Презентація)**
*   **Роль:** «Обличчя» одного користувача. Відповідає тільки за **відображення** даних.
*   **Принцип:** Це «дурний» компонент. Він нічого не знає про те, звідки беруться дані або як вони фільтруються.
*   **Вхідні дані:** Отримує всі необхідні дані (ім'я, email, телефон) через **`props`**.
*   **Структура:** Проста HTML-розмітка для відображення імені, email і телефону користувача.

### 3. Потік даних (Data Flow)

Потік даних **односпрямований і передбачуваний**, що є фундаментом надійних систем.

1.  `App.vue` отримує дані з **API**.
2.  Дані зберігаються в стані `users`.
3.  Користувач вводить текст в `input`, який оновлює `searchQuery`.
4.  Зміна `searchQuery` автоматично викликає перерахунок `filteredUsers`.
5.  Зміна `filteredUsers` викликає **реактивне перемальовування** списку.
6.  Новий відфільтрований список передається «вниз» в компоненти `UserCard` через `props`.

### 4. Ключові рішення

*   **Чому `ref`, а не `reactive`?**
*   Для **масиву** (`users`) обидва підходи спрацювали б. `ref` був обраний для уніфікації, оскільки для **примітиву** (рядка пошуку `searchQuery`) можна використовувати тільки `ref`.
*   **Чому `computed` для фільтрації?* *
*   Це **найефективніший (Принцип 9)** спосіб. Vue кешує результат `computed`. Функція фільтрації буде викликана **тільки тоді, коли зміниться `users` або `searchQuery`**, а не при кожному перемальовуванні. Це запобігає зайвим обчисленням і забезпечує високу продуктивність.